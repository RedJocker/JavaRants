* depends on

- [[file:../primitive_data_types/primitive_data_types.org][Java Primitive Data Types]]
- [[file:../local_variable/local_variable.org][Local Variables]]

* The `char` Type in Java

** Introduction

Before we dive into working with text and larger systems
of data in Java, it is foundational to understand the `char` type.
The char type is an interesting type with a dual nature.
On one hand it is the elementary unit of text representation,
the individual character,
while at the same time their underlying memory representation
is numeric following the unicode standard.
Mastering `char` will give you the base knowledge to work with Strings
and manipulating text data.

** The Numeric Nature of `char`

When we declare a `char` variable in Java,
what we're really doing is reserving space to store a number.
Each `char` requires 2 bytes of memory, or 16 bits.
This fixed size is determined by Java's commitment to Unicode,
an international standard that allows programmers to represent
characters from almost every written language on Earth
—not just the English alphabet or symbols found in
the ASCII table.

So, even though you see:
#+begin_src java
  char letter = 'A';
#+end_src
under the hood, Java is storing the actual
Unicode value that represents 'A',
which happens to be the number 65.
In technical terms, a `char` can hold any value
from 0 (`\u0000`) to 65,535 (`\uffff`).
This is different from some other languages,
which may limit chars to just a single byte.


You can see this numeric aspect in action:
#+begin_src java
  char c = 'A';
  System.out.println((int) c); // Prints: 65
#+end_src

This means that every character in Java
has a unique number used for storage and manipulation.

** Comparisons and Basic Arithmetic with `char`

Because `char` values are stored as numbers,
you can perform several familiar operations on them
—including comparisons and arithmetic.
This is a little surprising if you expect characters
to behave as pure text!

For example, comparison operators
(`==`, `!=`, `<`, `>`, `<=`, `>=`)
do not compare the letters themselves
but rather their underlying numeric codes:
#+begin_src java
  char a = 'A'; // code 65
  char b = 'B'; // code 66
  System.out.println(a < b); // true, because 65 < 66
#+end_src

Similarly, adding and subtracting with chars will use
their numeric values:
#+begin_src java
  char ch = 'A' + 1; // ch becomes 'B' (code value 66)
#+end_src

Imagine you want to iterate through the uppercase
English alphabet—you can do so by incrementing
a `char` in a loop!
While this appears to be a math operation,
it has a natural connection to text processing
—a theme you'll see often when working with characters.

** Characters and Text: From ASCII to Unicode

While the numeric features of `char`
are handy, the main reason we use chars is to represent text.
The `char` type was originally designed around the
ASCII table—which maps codes 0–127
to common characters like letters,
digits, punctuation, and control codes.
For example, 'a' is 97, 'A' is 65, and '0' (character zero) is 48.

But Java goes way beyond ASCII.
Unicode includes symbols from scripts all over the world,
mathematical and technical symbols, and emojis.
All of these can fit in `char` variables
(though some rare characters like certain
emojis require special handling).

Comparisons between chars become especially interesting
on the textual side.
For example:
#+begin_src java
  System.out.println('a' > 'A'); // true, because 97 > 65
#+end_src

This tells us that lowercase letters come
after uppercase letters in Unicode.
So, if you compare two chars to see which
comes first alphabetically,
keep in mind that the result
reflects their Unicode values.

** Escape Characters and Special Symbols

Java also allows you to represent non-printing
or special characters using escape sequences:
- `'\n'` for newline (line break)
- `'\t'` for tab
- `'\''` for a single quote

These escapes make it easier to handle text layout
and to include reserved or
invisible characters in your data.

** Raw data

Some other languages, like C have chars with size of one byte.
This makes char arrays =char[]= to be a good type to use
for raw processing of data.
In java the type that has only one byte is
named byte, so byte arrays =byte[]= are prefered types for
raw processing.
If you don't know what are arrays yet don't worry, they are
just a fixed collection of a certain type and we will spend more
time with them and other data stuctures later.

** The Gateway to Strings and Beyond

As we move toward working with Strings,
remember that Java Strings are essentially
immutable sequences of `char` values.
This means a full understanding of `char`
is foundational for text processing,
parsing, formatting, and much more.

As we move forward,
we’ll build on this understanding,
learning how to use chars to create Strings,
how to convert between numbers and text,
how to manage collections of character data efficiently
and even a class specialized in building strings.


** Summary

The modest `char` type serves as a bridge between
the numeric and textual worlds in Java.
Stored as a 2-byte unsigned integer number,
every char can be manipulated
as a value while also representing human-readable symbols
from Unicode.
Its flexibility allows both efficient
processing and expressive coding.
