* The `char` Type in Java

** Introduction

Before we dive into working with text and larger systems
of data in Java, it's essential to understand the `char` type,
which represents individual characters.
While you may already be familiar with primitive types such as
`boolean`, the `char` type may seem simple at first but actually
bridges both the numeric and textual worlds in Java programming.
Mastering `char` gives you a foundation for working with Strings
and manipulating text data before we move on to more
complex types and data structures.

** The Numeric Nature of `char`

When we declare a `char` variable in Java,
what we're really doing is reserving space to store a number.
Each `char` requires 2 bytes of memory, or 16 bits.
This fixed size is determined by Java's commitment to Unicode,
an international standard that allows programmers to represent
characters from almost every written language on Earth
—not just the English alphabet or symbols found in
the ASCII table.

So, even though you see:
#+begin_src java
  char letter = 'A';
#+end_src
under the hood, Java is storing the actual
Unicode value that represents 'A',
which happens to be the number 65.
In technical terms, a `char` can hold any value
from 0 (`\u0000`) to 65,535 (`\uffff`).
This is different from some other languages,
which may limit chars to just a single byte.


You can see this numeric aspect in action:
#+begin_src java
  char c = 'A';
  System.out.println((int) c); // Prints: 65
#+end_src

This means that every character in Java
has a unique number used for storage and manipulation.

** Comparisons and Basic Arithmetic with `char`

Because `char` values are stored as numbers,
you can perform several familiar operations on them
—including comparisons and arithmetic.
This is a little surprising if you expect characters
to behave as pure text!

For example, comparison operators
(`==`, `!=`, `<`, `>`, `<=`, `>=`)
do not compare the letters themselves
but rather their underlying numeric codes:
#+begin_src java
  char a = 'A'; // code 65
  char b = 'B'; // code 66
  System.out.println(a < b); // true, because 65 < 66
#+end_src

Similarly, adding and subtracting with chars will use
their numeric values:
#+begin_src java
  char ch = 'A' + 1; // ch becomes 'B' (code value 66)
#+end_src

Imagine you want to iterate through the uppercase
English alphabet—you can do so by incrementing
a `char` in a loop!
While this appears to be a math operation,
it has a natural connection to text processing
—a theme you'll see often when working with characters.

It's important to note: most math operations
between chars actually result in an
`int` value.
That allows you to use arithmetic to,
for example, calculate a character's difference
from 'A', and use that as an index or key.
We'll revisit these ideas as we study more
complex numeric types like integers and longs.

** Characters and Text: From ASCII to Unicode

While the numeric features of `char`
are handy, the main reason we use chars is to represent text.
The `char` type was originally designed around the
ASCII table—which maps codes 0–127
to common characters like letters,
digits, punctuation, and control codes.
For example, 'a' is 97, 'A' is 65, and '0' (zero) is 48.

But Java goes way beyond ASCII.
Unicode includes symbols from scripts all over the world,
mathematical and technical symbols, and emojis.
All of these can fit in `char` variables
(though some rare characters like certain
emojis require special handling—this will
become important when we talk about
text processing and strings).

Comparisons between chars become especially interesting on the textual side. For example:
#+begin_src java
  System.out.println('a' > 'A'); // true, because 97 > 65
#+end_src

This tells us that lowercase letters come
after uppercase letters in Unicode.
So, if you compare two chars to see which
comes first alphabetically,
keep in mind that the result
reflects their Unicode values.

** Escape Characters and Special Symbols

Java also allows you to represent non-printing
or special characters using escape sequences:
- `'\n'` for newline (line break)
- `'\t'` for tab
- `'\''` for a single quote

These escapes make it easier to handle text layout
and to include reserved or
invisible characters in your data.

** Raw data

Some other languages, like C have chars with size of one byte.
This makes char arrays =char[]= to be a good type to use
for raw processing of data.  
In java the type that has only one byte is
named byte, so byte arrays =byte[]= are prefered types for
raw processing.
If you don't know what are arrays yet don't worry, they are
just a fixed collection of a certain type and we will spend more
type with them and other data stuctures later.

** How `char` Fits into Java’s Type System

`char` is a primitive type—meaning it isn't
a class like String or ArrayList.
It holds a value directly, and it doesn’t have methods.
When you mix `char` with other types,
Java will often automatically promote it to an `int`
in expressions.
This can be useful, but it also means you have
to be aware of when your chars stop behaving
like text and start acting as numbers.

** The Gateway to Strings and Beyond

As we move toward working with Strings,
remember that Java Strings are essentially
immutable sequences of `char` values.
This means a full understanding of `char`
is foundational for text processing,
parsing, formatting, and much more.
Conversely, true “raw data” is not handled as `char`,
but as `byte`.
This distinction is especially important in applications
dealing with binary files, network streams,
or anything else that’s not strictly human-readable text.

As we move forward,
we’ll build on this understanding,
learning how to use chars to create Strings,
how to convert between numbers and text,
how to manage collections of character data efficiently
and even a class specialized in building strings.


** Summary

The modest `char` type serves as a bridge between
the numeric and textual worlds in Java.
Stored as a 2-byte unsigned integer number,
every char can be manipulated
as a value while also representing human-readable symbols
from Unicode.
Its flexibility allows both efficient
processing and expressive coding.
As you continue through this course,
you’ll see how these concepts prepare you for both
string manipulation and numerical computation.
